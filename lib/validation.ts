/**
 * Validation utilities for pastecn
 */

/**
 * Validates that a snippet ID has the correct format
 * IDs generated by nanoid use A-Za-z0-9_- alphabet
 * @param id - The snippet ID to validate
 * @returns true if valid, false otherwise
 */
export function validateSnippetId(id: string): boolean {
  if (!id || typeof id !== 'string') {
    return false
  }
  
  // nanoid uses A-Za-z0-9_- alphabet by default
  // Allow 1-50 characters for flexibility
  const nanoidPattern = /^[A-Za-z0-9_-]{1,50}$/
  return nanoidPattern.test(id)
}

/**
 * Validates that a path does not contain path traversal sequences
 * Rejects any path containing '../' to prevent directory traversal attacks
 * This aligns with shadcn CLI validation
 * @param path - The path to validate
 * @returns true if path is safe (no '../'), false otherwise
 */
export function validatePath(path: string): boolean {
  if (!path || typeof path !== 'string') {
    return false
  }
  
  // Reject any path containing '../' (path traversal)
  // This is what shadcn CLI checks for
  return !path.includes('../')
}

/**
 * Validates that a registry JSON object has the correct structure
 * for a shadcn/ui registry item
 * @param json - The JSON object to validate
 * @returns true if valid, false otherwise
 */
export function validateRegistryJson(json: unknown): boolean {
  if (!json || typeof json !== 'object' || json === null) {
    return false
  }
  
  const obj = json as Record<string, unknown>
  
  // Check $schema
  if (typeof obj.$schema !== 'string' || !obj.$schema.includes('schema/registry-item.json')) {
    return false
  }
  
  // Check name
  if (typeof obj.name !== 'string' || obj.name.trim() === '') {
    return false
  }
  
  // Check type
  const validTypes = ['registry:file', 'registry:component', 'registry:hook', 'registry:lib', 'registry:block']
  if (typeof obj.type !== 'string' || !validTypes.includes(obj.type)) {
    return false
  }
  
  // Check files array
  if (!Array.isArray(obj.files) || obj.files.length === 0) {
    return false
  }
  
  // Validate each file
  for (const file of obj.files) {
    if (!file || typeof file !== 'object') {
      return false
    }
    
    const fileObj = file as Record<string, unknown>
    
    // Check path exists and is valid (no path traversal)
    if (typeof fileObj.path !== 'string' || fileObj.path.trim() === '') {
      return false
    }
    if (!validatePath(fileObj.path)) {
      return false
    }
    
    // Check target if it exists (for files)
    if (fileObj.target !== undefined) {
      if (typeof fileObj.target !== 'string' || fileObj.target.trim() === '') {
        return false
      }
      if (!validatePath(fileObj.target)) {
        return false
      }
    }
    
    // Check type
    if (typeof fileObj.type !== 'string' || !validTypes.includes(fileObj.type)) {
      return false
    }
    
    // Check content (must be string, can be empty)
    if (typeof fileObj.content !== 'string') {
      return false
    }
  }
  
  return true
}